<html>
<head>
	<meta http-equiv="origin-trial" content="ApM2LRrizp8n6n1p9IaYNL9tbGYTRob0jgm5wOr1jPQeXXyKTqNbaZKaC2LgVTyizCde6tC6XL0ZeH28L/z3EAEAAABdeyJvcmlnaW4iOiJodHRwczovL3BvdHJlZS5vcmc6NDQzIiwiZmVhdHVyZSI6IldlYkdQVSIsImV4cGlyeSI6MTY0MzE1NTE5OSwiaXNTdWJkb21haW4iOnRydWV9">
</head>
<body>

<style>

body{
	margin: 0px;
	padding: 0px;
}

#canvas{
	width: 100%;
	height: 100%;
	margin: 0px;
	padding: 0px;
}

#rendermode_container{
	background-color: white;
	padding: 5px;
	border: 2px solid black;
	font-family: Arial, Helvetica, sans-serif;
}

</style>

<div style="display: grid; width: 100%; height: 100%; grid-template-columns: 400px 1fr">
	<div id="rendermode_container">
		<b>Render Mode</b>

		<a href="https://github.com/m-schuetz/webgpu_wireframe_thicklines">[github]</a>
	</div>
	<div>
		<canvas id="canvas"></canvas>
	</div>
</div>



<script type="module">
	// adapted from https://github.com/toji/hello-triangle-webgpu 

	import {bunny} from "./bunny.js";
	import {cube} from "./cube.js";
	import {mat4, vec3} from "./libs/gl-matrix/gl-matrix.js";
	import {renderMesh} from "./renderMesh.js";
	import {computeYarn} from "./computeYarn.js";
	import {createRenderer} from "./renderer.js";

	let canvas  = document.getElementById("canvas");
	let renderer = await createRenderer(canvas);

	function loop(){

		let renderPassDescriptor = {
			colorAttachments: [{
				view:         renderer.context.getCurrentTexture().createView(), 
				loadOp:       "clear",
				clearValue:   [0.1, 0.2, 0.3, 1.0],
				storeOp:      "store",
			}],
			depthStencilAttachment: {
				view:             renderer.depth.createView(),
				depthClearValue:  1.0,
				depthLoadOp:      "clear",
				depthStoreOp:     "store",
			},
		};

		let commandEncoder = renderer.device.createCommandEncoder();

		let elMesh = document.getElementById("rendermode_mesh");
		let elWireframe = document.getElementById("rendermode_wireframe");
		let elWireframeThick = document.getElementById("rendermode_wireframe_thick");
		let elQuads = document.getElementById("rendermode_quads");

		let view = mat4.create();
		mat4.translate(view, view, vec3.fromValues(0, 0, -4));
		let now = performance.now() / 1000;
		mat4.rotate(view, view, now, vec3.fromValues(0, 1, 0));


		let numVertices = 100;

		let bufIndirect = renderer.device.createBuffer({
			size: 512,
			usage: GPUBufferUsage.VERTEX 
				| GPUBufferUsage.INDEX  
				| GPUBufferUsage.COPY_DST 
				| GPUBufferUsage.COPY_SRC 
				| GPUBufferUsage.STORAGE
				| GPUBufferUsage.INDIRECT,
			mappedAtCreation: false,
		});

		let bufPositions = renderer.device.createBuffer({
			size: 12 * numVertices,
			usage: GPUBufferUsage.VERTEX 
				| GPUBufferUsage.INDEX  
				| GPUBufferUsage.COPY_DST 
				| GPUBufferUsage.COPY_SRC 
				| GPUBufferUsage.STORAGE,
			mappedAtCreation: false,
		});

		let bufColors = renderer.device.createBuffer({
			size: 4 * numVertices,
			usage: GPUBufferUsage.VERTEX 
				| GPUBufferUsage.INDEX  
				| GPUBufferUsage.COPY_DST 
				| GPUBufferUsage.COPY_SRC 
				| GPUBufferUsage.STORAGE,
			mappedAtCreation: false,
		});

		let model = {
			numVertices,
			positions: bufPositions,
			colors: bufColors,
			indirect: bufIndirect
		};

		computeYarn(model, view, renderer, commandEncoder);

		let passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
		renderMesh(model, view, renderer, passEncoder);

		passEncoder.end();
		let commandBuffer = commandEncoder.finish();
		renderer.device.queue.submit([commandBuffer]);

		requestAnimationFrame(loop);
	}

	loop();

</script>

</body>
</html>